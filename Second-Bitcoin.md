# 目录
- [比特币的简单介绍](#比特币的简单介绍)
- [数字货币VS电子货币](#数字货币VS电子货币)
- [比特币解决的问题](#比特币解决的问题)
- [P2P网络交易原理](#P2P网络交易原理)
  * [数字签名](#数字签名)
    + [公私钥](公私钥)
    + [私钥](#私钥)
    + [公钥](#公钥)
  * [交易过程](#交易过程)
- [挖矿原理](#挖矿原理)
  * [区块的头部字段](#区块的头部字段)
  * [POW机制](#POW机制)
# 比特币的简单介绍
**比特币是人类历史上第一种数字货币**！

**什么是数字货币？数字货币就是基于数学加密原理构建的不可伪造的货币系统，而比特币是一个基于数据加密原理构建的分布式的数字货币系统**！

**比特币与区块链的关系是什么？一句话概括：比特币使用了区块链技术实现了数字货币的可信支付**！

比特币是2008年10月中本聪在密码学朋克论坛上发表的一篇文章：[比特币：一种点对点的电子现金系统](https://bitcoin.org/bitcoin.pdf)，这个可以看成是比特币的白皮书；随后在2008年11月，中本聪发布了比特币的第一版代码。
2009年1月，中本聪挖出了比特币的第一个区块——创世区块，标志着比特币网络的正式运行。


# 数字货币VS电子货币
其实无论是现金支付还是电子货币支付，交易的过程都需要通过银行这个媒介进行，现金的通过银行则是通过税法来体现，电子货币的交易的通过银行则是第三方机构与银行签订的合约进行！只有通过银行了，国家财政才能知道近年来的货币流转程度，才能知道最近国家的经济情况，从而根据这种情况去印刷新版货币来流入市场，保证经济，防止经济膨胀和经济紧缩。所以，无论任何交易都要通过银行这个机构来进行。

那么数字货币则是不需要一个类似银行的中央信任机构，就可以通过全网的P2P网络进行发行和流通，这听上去不可思议。

# 比特币解决的问题
比特币就是通过技术手段解决了现金电子化后交易的清结算问题！清结算的官方定义是：**对交易数据依据机构和交易类型进行分类汇总，并计算结算金额的过程**。

传统的基于银行机构进行交易，本质上都是通过中央数据库，确保两个交易用户余额的以增一减，这个交易高度依赖开发和运维人员，以及完善的风控机制。

比特币则是通过区块链技术，把整个账本全部公开，人手一份，全网相同，因为，如果个人修改账本，是不会被其他人承认的。

比如：我们现在有一个交易发生，交易金额是M0，并且是A向B出售货物，B向A付款M0，如果通过电子货币进行交易，是不是可以理解为以下流程。B手上目前有银行的M0的负债，也就是B有M0个资产，那么进行交易后，也就是B的资产减少M0，A的资产增加M0，银行向B的负债，现在转化为银行向A的负债。对银行来说整个负债是平衡的。那么如果通过现金，是不是就不用通过银行这个机构进行交易，就不会产生资产与负债的关系。所以通过电子货币，无论怎样都绕不开中央信任机构的问题，因为用户需要信任银行不会篡改余额！

比特币就是可以理解为电子上的现金支付，也就是点对点的支付系统！

# P2P交易原理
比特币既然可以理解为基于电子的现金交易，那么是怎么实现的？是通过一种P2P的交易形式：假如A和B想电子的现金交易的方式进行交易，那么一种创建交易的方式是，A声称自己有1万元，这显然是不可信的；那么如果A对自己的话能够做一个验证，确实有1万元，那么是否可以认定A是可以进行交易；但是这个可信度还是不够，如果能够保证A有这1万元，并且一定会想去交易即可，是不是就可以保证交易是肯定发生的？所以，这个方法就是P2P交易。

确保A有1万元，是交易网络进行判断的，而确保A一定想发生交易，是通过数字签名进行的。

## 数字签名
这个概念就类似于签合同，如果继续上面的例子，如果A想要进行交易，就需要先做一个声明，并且在整个声明上签字，A签字的含义就是：A证明自己拥有1万元，并且保证自己是希望进行交易的。所以数字签名就保证了交易的有效性！！这个签名是通过数据签名算法（公私钥）进行的，比验证笔记更加可行！

### 公私钥
在数字签名的过程中，每个人都可以自己生成一个密钥对，这个密钥对是包含一个私钥和一个公钥，私钥是自己严格保密的，公钥是可以公开给别人的。在比特币中，公钥是可以公开发布给全网的！

整个签名的过程大致是这样：A对想要进行1万元交易这个消息进行签名的时候，可以用自己的私钥进行签名，然后把这个消息和公钥发布出去，网络上任何人都可以收到这个消息和公钥，而别人想要确认这个消息，就只需要拿公钥去验证，如果验证通过了， 那么就可以完全肯定这个消息是A发出去的。

**而这个公私钥的生成过程也是通过上一个文章所说的Hash进行处理的**。

**一般常用的数字签名的算法有三种：RSA算法、DSA算法和MCDSA算法，比特币采用的签名算法是椭圆曲线签名算法，ECDSA算法，使用的是定义好的标准曲线secp256k1函数**，公式是`y^2 = x^3 + 7` 。

**ECDSA算法需要的是一个私钥来生成一个公钥，并且由私钥是很难推算出公钥的，所以不需要保存公钥**。私钥本质上就是一个1～2^256的随机数， **而比特币的私钥确切的说是比2^256次方要小一点，而比特币的公钥是通过私钥生成的两个256位的整数**！！所以**用户只要提供一个256位的整数组成私钥即可，但是这个私钥最好是通过使用编程语言提供的安全随机数算法来生成**！因为，比特币规定，不可以修改公私钥，并且如果别人获取了你的私钥，那么你无法改动你的账户，他也能轻松获取该账户下的比特币！这里，公钥更像是你的银行卡卡号，私钥则是银行卡密码。

**并且全网所有用户都可以通过公钥来查看你账户中的余额**。

但是实际上，你的公钥上传到网络中，并不是你真实的公钥内容，而是经过处理后的内容传输到网络中，那么公钥这么做了，私钥其实也会经过处理，因为256位整数会非常大，经过处理通过hash来判别私钥是否出问题。这个处理过程有两种：一种是压缩；一种是非压缩。压缩对应的就是压缩私钥和压缩公钥，非压缩也是类似（非压缩已经不常用了）。接下来我们具体的了解一下这个过程！

### 私钥
首先，我们已经知道了私钥是256位二进制整数组成的，但是想要记住这个私钥是非常难得，而且你即使输错了某些位，那么该私钥依旧是一个有效的私钥，判断不了你输入的私钥是否正确，所以比特币有一种对私钥进行编码的方法，既能判断私钥是否成立，又能对私钥进行加密，那么这种编码方法就是Base58。

在了解之前需要知道几个概念：1、**对私钥进行 Base58 编码有两种方式，一种是非压缩的私钥格式，一种是压缩的私钥格式**，非压缩格式现在基本不用了！2、**私钥经过Base58编码处理完成之后的私钥地址，被称为WIF**(Wallet Import Format 钱包导入格式)。

非压缩的WIF过程如下图：

![非压缩的WIF的过程](./images/非压缩格式的WIF过程.jpg)

过程描述如下：第一步，通过计算机随机数编码，获得了一个随机的256位二进制整数的私钥，也就是32字节的私钥，这里记私钥为key；第二步：**之后在这个私钥的开头添上一字节 —— `0x80` 做为前缀**，这里记 0x80+私钥 为A；第三步：这里对**A进行dhash**（两次sha256）的hash计算；第四步，**把这个dhash计算的结果的前4字节内容获取过来，加在A的末端**，这样，整体就是32+1+3=37字节的长度；第五步：之后对这串内容进行Base58计算。这样就得到了WIF的私钥地址，**这个非压缩格式的WIF总是以5开头**。

压缩的WIF过程如下：

![压缩的WIF的过程](./images/压缩格式的WIF过程.jpg)

压缩的WIF的生成过程步骤完全等同于非压缩的WIF的生成过程，唯一不同的则是内容上的不容，发生在第二步，**压缩格式的WIF不仅需要添加上 `0x80`的后缀，还需要添加 `0x01`的后缀**，之后这一个整体打包进行第三步的dhash计算。其他过程都等同于非压缩格式，这里不做过多赘述，看图即可理解！**这里也有个规律，压缩格式的WIF总是以K或者是L作为开头**！**记住都是大写的**！

**疑问1**：为什么需要在尾部加上4字节才能在计算Base58呢？
<br>**答**：这是因为这4字节在这个内容中起到了校验位的作用！而加上前缀或者加上后缀都可以理解为是比特币的协议规定的！

**疑问2**：如果按照上面所说的，为什么密钥的压缩格式的WIF表示要比非压缩格式的WIF还要长一位？
<br>**答**：确实是长一位，但是密钥的压缩与非压缩WIF格式对应的是公钥的压缩和非压缩格式。**第一：在比特币的网络中，并不允许公钥直接的传输在网络中，而是需要通过编码才能在网络中传输，这个私钥经过编码转化后的内容，我们称之为：地址。第二：我们通过ECDSA算法中的secp256k1函数得知，私钥作为输入，则会有两个32字节长度的整数输出，这两个都是公钥，这里记作`(x, y)`；如果私钥用非压缩的WIF编码进行处理，那么公钥也需要转化成非压缩格式的地址，这个非压缩格式的公钥是需要`x`和`y`两个公钥拼在一起，在经过一定处理才能得出地址；但，如果私钥用的是压缩格式的，那么地址和公钥也是需要压缩格式转化的，这个公钥的表示就只需要`x`和`y`中任意一个公钥作为内容即可，然后再经过转化就可变成地址了**！这个转化的过程我在公钥，也就是下面的小章节中介绍，现在我放出私钥，公钥，地址三者之间的关系。记住，**因为hash函数的单向性，所以，无论如何，地址是反推不出公钥，公钥反推不出私钥的**！

![公私钥与地址和WIF之间的关系](./images/公私钥与地址和WIF之间的关系.jpg)

### 公钥
通过上面的第二个问题，我们可以得出，公钥是通过私钥经过ECDSA算法中的ECC曲线（secp256k1曲线）得出的两个结果，并且两个结果都是公钥。**根据ECC曲线的特点，一个公钥x可以推出另一个公钥y，但是需要提前知道y的奇偶性**；那么我们也**可以通过非压缩格式的公钥推测出压缩格式的公钥**。原因如下：**压缩格式的公钥实际上只保留了`x`这一个256位整数，但是需要根据 `y` 的奇偶性在 `x` 的前面添加 `02` 或者 `03` 作为前缀。`y` 为偶数时添加 `02`，为奇数时添加 `03`。**

综上可以得出，**非压缩格式的公钥其实是两个256位（32字节）的整数拼在一起的结果，整体是64字节，压缩格式的公钥其实是一个256位（32字节）的整数加上一个1字节的奇偶判断位，整体是33字节**。由此可以得出，无论是私钥的压缩非压缩还是公钥的压缩非压缩，都是因为公私钥的对应关系以及公钥的这个特性得出的！

了解了以上这么多，我们再来了解一下公钥转化成地址的做法。这里拿压缩格式公钥为例：先看图了解大概

![压缩格式公钥转地址](./images/压缩格式公钥转地址.jpg)

**第一步：压缩格式公钥是33字节长度；第二步：对这个压缩格式公钥进行hash160编码方法进行计算（先经过依次hash256，在经过依次RipeMD160）得到20字节长度的一个Hash值；第三步，按照比特币的规范要求，在这个20字节长度的Hash前添加上`0x00`前缀；第四步：对这个21字节长度的数据经过dhash计算，并取出前4字节作为校验位；第五步：把这四字节的校验位拼接到第三步结果的21字节长度的数据上，最后就得到了总长度位25位的一个hash数据；第六步：对这25位字节长度的数据经过Base28编码，就可以得到一个总是以`1`开头的一个比特币地址了**。这个地址是可以发送公布到全网范围的！

**注意：**
<br>1、**这个地址无论是针对压缩格式的公钥还是非压缩格式的公钥，计算结果都是以1开头的地址**！
<br>2、因为经过了Hash计算，所以光从地址的角度想逆推看出公钥是压缩还是非压缩的，这个是无法区分的！
<br>3、仅仅提供地址是不能让其他人得知公钥的。一般来说公开公钥是没有安全风险，并且实际上，如果某个地址上有对应的资金，要花费该资金，就需要提供公钥。如果某个地址的自己被华为过至少依次，那么该地址的公钥实际上就是公开的了！
<br>4、**这个地址才是在交易过程中比特币一条交易记录中所记载的地址，交易记录中记载的并不是公钥**！


## 交易过程
在比特币中，在区块链上的每个区块，都至少包含一笔交易，并且每个区块的第一个交易通常是CoinBase交易，也就是矿工挖矿的奖励，后续的交易内容才是用户之间的交易。
<br>我们再来看记录在区块链上的交易。每个区块都记录了至少一笔交易，一笔交易就是把一定金额的比特币从一个输入转移到一个输出：
<br>注：这个就可以看作区块链的一部分，新的区块是加在链表的尾部，也就是右边！

![](./images/交易1.png)

例如，小明把两个比特币转移给小红，这笔交易的输入是小明，输出就是小红。实际记录的是双方的公钥地址。

如果小明有50个比特币，他要转给小红两个比特币，那么剩下的48个比特币应该记录在哪？比特币协议规定一个输出必须一次性花完，所以，小明给小红的两个比特币的交易必须表示成：

![](./images/交易2.png)

小明给小红2个比特币，同时小明又给自己48个比特币，这48个比特币就是找零。所以，一个交易中，一个输入可以对应多个输出。

当小红有两笔收入时，一笔2.0，一笔1.5，她想给小白转3.5比特币时，就不能单用一笔输出，她必须把两笔钱合起来再花掉，这种情况就是一个交易对应多个输入和1个输出：

![](./images/交易3.png)

如果存在找零，这笔交易就既包含多个输入也包含多个输出：

![](./images/交易4.png)

在实际的交易中，输入比输出要稍微大一点点，这个差额就是隐含的交易费用，交易费用会算入当前区块的矿工收入中作为矿工奖励的一部分：

![](./images/交易5.png)

当我们要简单验证某个交易的时候，例如，对于交易`f36abd`，它记录的输入是`3f96ab`，索引号是`1`（索引号从`0`开始，`0`表示第一个输出，`1`表示第二个输出，以此类推），我们就根据`3f96ab`找到前面已发生的交易，再根据索引号找到对应的输出是0.5个比特币，所以，这笔交易的输入总计是0.5个比特币，输出分别是0.4个比特币和0.09个比特币，隐含的交易费用是0.01个比特币：

![](./images/验证交易.jpg)

以上就是交易的全流程！

## 挖矿原理
挖矿并不是真的挖矿，哈哈哈哈！这个冷笑话可能一点不好笑~。其实在P2P网络中，总有一类节点在不停的去进行计算，目的是把新的交易打包成新的区块并附加到区块链上。又因为区块链的交易部分第一条交易就是矿工的挖矿奖励，意思就是每产出一个新的区块，创建该区块的矿工会分的奖励。这个过程类似挖矿，故其名为矿工。

在了解挖矿的过程之前，我们需要先了解几个部分的知识：区块链中每个区块的头部字段包含哪些，以及区块链中最重要POW（工作量证明）。

### 区块的头部字段
区块链的每个区块可以理解包含两大信息：**区块的头部信息以及整个交易的主体信息**。

区块的整个交易信息包含的该区块的每个交易内容，并且**第一条交易信息通常都是CoinBase**（矿工挖矿的奖励）！

区块的头部信息包含6个字段：Version（版本），Previous Block Hash（前向区块的区块Hash）、Merkle Root（交易的部分的Hash）、TimeStamp（时间）、Bits（难度目标）、Nonce（随机数）。这6个字段一定要知道他们的用处，以及长度！接下来分别详细介绍一下这6个字段的信息

**Version**：长度为**4字节**，主要是随着比特币协议的升级而改变。该字段并不是很重要！
<br>**Previous Block Hash**：长度为**32字节**，存储**前向区块的Hash**，在挖矿的过程中，该信息会预先得到！
<br>**Merkle Root**：长度为**32字节**，存储当前区块的**所有交易的数据的dhash值**！
<br>**Timestamp**：长度为**4字节**，用于记录区块生成的时间；
<br>**Bits**：长度为**4字节**，用于**记录当前区块的挖矿难度目标**，主要是**用于调整POW算法的难度**，以维持平均每10分钟生成一个新区块的时间；
<br>**Nonce**：长度为**4字节**，用于**在POW过程中被不断的调整的**，主要用于在挖矿过程中一直去调整这个值，来找到一个满足难度的区块头hash值。

### POW机制
未完待续






